#!/usr/bin/env ruby

# ------------------------------------------------------------
# Helper classes

class InputFile
  include Comparable

  # Regexp for files generated by The Unarchiver (https://theunarchiver.com/);
  # probably need something different for production
  PATTERN = /^Page (?<page>[0-9]+).*\.(?<ext>[^.]+)$/.freeze

  attr_reader :page, :ext, :path

  def initialize(page, ext, path)
    @page = page.to_i
    @ext = ext
    @path = path
  end

  def <=>(other)
    return unless other
    return unless other.class == self.class

    order = page <=> other.page
    return order if order != 0

    order = ext <=> other.ext
    return order if order != 0

    path <=> other.path
  end

  class << self
    def from_path(path)
      return unless path
      return if File.directory?(path)
      raise ArgumentError, "Not a file: #{path}" unless File.file?(path)
      return unless (match_data = PATTERN.match(File.basename(path)))

      InputFile.new(match_data[:page], match_data[:ext], path)
    end

    def all_from_directory(dir)
      glob = File.join(dir, '*.*')
      Dir.glob(glob).each_with_object([]) do |p, ff|
        next unless (input_file = InputFile.from_path(p))

        ff << input_file
      end
    end
  end
end

class CopyAndRenameTask
  attr_reader :source_dir, :target_dir

  def initialize(prefix, source_dir, target_dir)
    @prefix = prefix
    @source_dir = source_dir
    @target_dir = target_dir
  end

  def files
    @files ||= InputFile.all_from_directory(source_dir).sort
  end

  def files_by_name
    @files_by_name = {}.tap do |ff|
      files.each do |f|
        canonical_name = canonical_name_for(f)
        if ff.key?(canonical_name)
          warn "Ignoring #{f.path}; previous file #{ff[canonical_name]} has same canonical name #{canonical_name}"
        else
          ff[canonical_name] = f
        end
      end
    end
  end

  def empty?
    files.empty?
  end

  def canonical_name_for(input_file)
    formatted_page_number = format("%0#{max_page_digits}d", input_file.page)
    basename = "#{formatted_page_number}.#{input_file.ext}"
    return basename unless prefix

    "#{prefix}-#{basename}"
  end

  def last_page
    @last_page ||= files.last&.page
  end

  def max_page_digits
    @max_page_digits ||= empty? ? 0 : Math.log(1 + last_page, 10).ceil
  end

  def copy_and_rename!
    files_by_name.each do |canonical_name, f|
      canonical_path = File.join(target_dir, canonical_name)
      warn("Copying #{f.path} to #{canonical_path}")
      FileUtils.cp(f.path, canonical_path)
    end
  end
end

# ------------------------------------------------------------
# Main program

# TODO: proper arg parsing
def source_dir
  ARGV[0].tap do |dir|
    raise ArgumentError, 'No source directory provided' unless dir
    raise ArgumentError, 'Specified source is not a directory' unless File.directory?(dir)
  end
end

def target_dir
  ARGV[1].tap do |dir|
    return '.' unless dir
    raise ArgumentError, 'Specified source is not a directory' unless File.directory?(dir)
  end
end

def prefix
  ARGV[2]
end

CopyAndRenameTask.new(prefix, source_dir, target_dir).copy_and_rename!
